h2. Основные принципы работы Docker

Docker базируется на технологиях namespaces и cgroups (первая обеспечивает изоляцию, вторая — группировку процессов и ограничение ресурсов).
В Docker присутствуют два базовых понятия:

#* *Образ* - является шаблоном только для чтения с набором инструкций для создания контейнера
Можно собрать образ с нуля, обновить или загрузить и использовать образы, созданные другими пользователями. Образ может быть самодостаточным или являться дополнением другого образа. Образ Docker описывается в специальном текстовом файле с именем Dockerfile.

#* *Контейнер* - является исполняемым экземпляром образа. Возможно создавать, запускать, останавливать, перемещать или удалять контейнер.
*Что происходит при запуске контейнера:* 
Утилита docker связывается с демоном dockerd на локальной машине и просит запустить нужный образ в изолированном контейнере.
Демон dockerd идет в каталог, в котором хранятся образы (по умолчанию, /var/lib/docker) и либо находит там нужный образ файловой системы и переходит к последнему шагу, если же его на нашей машине нет - он обратится к Docker Hub ("облачное хранилище":https://hub.docker.com/explore/, в которое можно загружать собственные образы) и будет искать этот образ там. Если он его находит - скачивает его.

Получив нужный образ, dockerd монтирует его файловую систему, делает в нее chroot и запускает указанную в последнем аргументе команду, ограничив ее «область видимости» с помощью namespaces (по сути, отрезал ей доступ к основной ФС, процессам хост-системы), контейнеру присваивается любой свободный IP из локальной подсети. При этом в контейнер можно, например, прокинуть файлы устройства текущего терминала для отрисовки псевдографического интерфейса программ, подключить STDIN, пробросить переменные окружения и т.д.

# Особенности Docker

Каждый новый запуск контейнера происходит «с нуля», а все изменения, сделанные в прошлом сеансе, теряются. При этом завершение работы контейнера происходит после завершения последнего работающего в нем процесса. Чтобы изменения сохранились после того, как мы завершили сеанс необходимо закоммитить изменения. 

Так как Docker завершает работу контейнера сразу после того, как будет завершен запущенный в нем процесс, например, nginx, который по умолчанию демонизируется, то есть форкает новый процесс и завершает тот, что мы запустили руками, то Docker сразу после этого завершает и контейнер, убивая форкнутый Docker. Конкретно в случае с nginx обойти эту проблему можно, добавив первой строкой в его конфиг:

<pre>
daemon off; 
</pre>

Для других демонов потребуются свои настройки.
Для того чтобы контейнеры могли общаться между собой и с внешним миром, Docker автоматически:
Создаёт сетевой мост docker0, если он не существует
Выполняет поиск диапазона IP адресов не пересекающихся с существующими на хосте маршрутами.
Случайно выбирает IP из заданного диапазона.
Выбранный адрес присваивает интерфейсу docker0.
Настраивает правила NAT для внешнего сетевого интерфейса. 
*Dockerfile* — по сути, эквивалент Makefile, который позволяет собирать образы для Docker. Его назначение — упростить создание новых образов без необходимости запускать контейнер, производить в нем какие-то операции и выполнять коммит. Для сборки контейнера достаточно положить Dockerfile и все файлы, которые будут добавлены в него(при помощи директивы ADD), в какой-нибудь каталог и выполнить следующую команду:

<pre>
docker build test/test_1.0:latest
</pre>

# Основные директивы для работы с DOCKERFILE:

#* FROM - Должна быть первой инструкцией в Dockerfile, указывающей, из какого образа нужно построить образ.
#* MAINTAINER - информация об авторе образа и его email
#* RUN - исполняет команду в конкретном образе
#* ADD - добавляет файлы или каталоги из нашего билд-окружения в образ
#* VOLUME - добавление тома в образ (каталог в одном или более контейнерах или каталог хоста). Т.о. создается точка монтирования для любого контейнера, созданного из данного образа
#* EXPOSE - указание определенного порта, на котором должен работать контейнер
#* CMD - выполнение команды после запуска контейнера
#* WORKDIR - указание рабочей директории, откуда происходит исполнения директивы CMD
#* USER - пользователь, под которым должен быть запущен контейнер
В любой момент к контейнеру можно подключиться с помощью команды:

<pre>
docker exec
</pre> 

с целью просмотреть логи или изменить настройки, но во время работы виртуального окружения информация потеряется, если мы завершим работу виртуального окружения, а вместе с ней исчезнут логи и изменения, внесенные в настройки. 
Пример:

<pre> docker exec -it 37d7f5f33418 bash </pre>

Docker не умеет собирать логи отдельных приложений, но умеет накапливать вывод STDOUT, то есть любой консольный вывод. Т.о. можно, например, изменить конфиг nginx так, чтобы логи сыпались в /dev/stdout, а затем просматривать их с помощью команды docker logs:

 При завершении работы контейнера - Docker сохраняет метаинформацию о контейнере. Т.е. все данные указанные с помощью аргументов при запуске контейнера - его имя, каталоги, которые нужно пробросить в контейнер, порты, переменные окружения и тому подобное, - вся эта информация будет сохранена при завершении контейнера и, чтобы запустить его в следующий раз уже не придется указывать это все заново, а достаточно просто выполнить такую команду (вместо ID можно использовать имя):

<pre>
docker start ID-контейнера
</pre>

 Docker поддерживает механизм томов общих каталогов: возможен вариант обмена данными через общие каталоги как строго внутри группы контейнеров, так и обмена данными между контейнерами и хост-машиной. Важно отметить следующие особенности механизма Share Directories:

#* Изменения данных производятся непосредственно в файле тома общего каталога, без участия механизма копирования при записи (copy-on-write), потому изменения происходят быстро, что хорошо для работы с большими файлами.

#* Изменения данных в томах общих каталогов не учитываются командой commit, потому что они не записываются как изменения файловой системы контейнера.

#* Для использования общего тома - не обязательно что бы контейнер при котором был создан этот том был запущен, но запуск контейнера к которому "привязан" том может застраховать данные тома от случайного удаления командой rm.

#* Тома общих каталогов существуют пока существует хотя бы один контейнер, подключенный к этому тому. Это значит что изначальный контейнер-владелец тома может быть удалён, но том будет существовать пока существуют контейнеры использующие его.

невозможно резервировать данные тома используя docker export/save/cp, т.к. том не является частью образа контейнера. Но возможно создать контейнер, подключенный к общему каталогу на хост-машине и к резервируемому контейнеру, после чего выгрузить содержимое резервируемого тома в хост-машину.

Если запущенный контейнер работает, но недоступен для конфигурирования (например в нём не запущен bash/sshd), то можно сделать chroot:

<pre>
docker inspect c274c40dda3d | fgrep '"ID"'  # Получаем ID контейнера
chroot $HOME/containers/ID/root  /bin/bash
</pre>Где $home -  рабочий каталог docker

*Линковка контейнеров*. Docker предоставляет систему линковки, позволяющую связать множество контейнеров вместе и отправлять информацию о соединении от одного контейнера другому, используя имя контейнера (ключ --link name:alias).
